-- ============================================================================
-- Migration: Master Data Translations System
-- Date: 2024-12-15
-- Description: Complete translation system for master data with triggers
-- ============================================================================

-- =============================================================================
-- PREREQUISITES: Helper Functions
-- =============================================================================

-- Get all English locale codes
CREATE OR REPLACE FUNCTION get_english_locales()
RETURNS TEXT[] AS $$
BEGIN
    RETURN ARRAY(
        SELECT code FROM locales 
        WHERE code LIKE 'en-%' AND is_active = TRUE
        ORDER BY code
    );
END;
$$ LANGUAGE plpgsql STABLE;

-- Title case conversion helper
CREATE OR REPLACE FUNCTION to_title_case(input_text TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN initcap(replace(replace(input_text, '_', ' '), '-', ' '));
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- =============================================================================
-- MASTER DATA TRANSLATIONS TABLE
-- =============================================================================

CREATE TABLE IF NOT EXISTS master_data_translations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Reference to master data
    master_data_type_id UUID REFERENCES master_data_types(id) ON DELETE CASCADE,
    master_data_value_id UUID REFERENCES master_data_values(id) ON DELETE CASCADE,
    
    -- What we're translating
    translation_target VARCHAR(20) NOT NULL CHECK (translation_target IN ('type', 'value')),
    
    -- Translation data
    locale_code TEXT NOT NULL REFERENCES locales(code),
    translated_label TEXT NOT NULL,
    translated_description TEXT,
    
    -- Status
    status translation_status DEFAULT 'published',
    is_verified BOOLEAN DEFAULT FALSE,
    is_auto_generated BOOLEAN DEFAULT TRUE,
    
    -- Multi-tenant
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Audit trail (complete)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES profiles(id),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    updated_by UUID REFERENCES profiles(id),
    is_active BOOLEAN DEFAULT TRUE,
    
    -- Constraints
    CONSTRAINT mdt_reference_check CHECK (
        (master_data_type_id IS NOT NULL AND master_data_value_id IS NULL AND translation_target = 'type') OR
        (master_data_type_id IS NULL AND master_data_value_id IS NOT NULL AND translation_target = 'value')
    )
    -- Note: Unique constraints moved to partial indexes below
);

-- Partial unique indexes (only apply when the relevant ID is NOT NULL)
CREATE UNIQUE INDEX IF NOT EXISTS idx_mdt_unique_type 
    ON master_data_translations(master_data_type_id, locale_code, COALESCE(organization_id, '00000000-0000-0000-0000-000000000000'::uuid))
    WHERE master_data_type_id IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS idx_mdt_unique_value 
    ON master_data_translations(master_data_value_id, locale_code, COALESCE(organization_id, '00000000-0000-0000-0000-000000000000'::uuid))
    WHERE master_data_value_id IS NOT NULL;

-- Other Indexes
CREATE INDEX IF NOT EXISTS idx_mdt_type ON master_data_translations(master_data_type_id) WHERE master_data_type_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_mdt_value ON master_data_translations(master_data_value_id) WHERE master_data_value_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_mdt_locale ON master_data_translations(locale_code);
CREATE INDEX IF NOT EXISTS idx_mdt_org ON master_data_translations(organization_id);
CREATE INDEX IF NOT EXISTS idx_mdt_active ON master_data_translations(is_active) WHERE is_active = TRUE;

-- Comments
COMMENT ON TABLE master_data_translations IS 'Translations for master data types and values';
COMMENT ON COLUMN master_data_translations.translation_target IS 'Whether translating a type or value';
COMMENT ON COLUMN master_data_translations.is_auto_generated IS 'TRUE if generated by trigger, FALSE if manually edited';

-- =============================================================================
-- TRANSLATION SOURCE TYPE ENUM
-- =============================================================================

DO $$ BEGIN
    CREATE TYPE translation_source_type AS ENUM (
        'schema_table',
        'schema_column', 
        'enum_value',
        'master_data_type',
        'master_data_value',
        'ui_string',
        'content'
    );
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- =============================================================================
-- TRANSLATION REGISTRY (for tracking auto-generated translations)
-- =============================================================================

CREATE TABLE IF NOT EXISTS translation_registry (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Source identification
    source_type translation_source_type NOT NULL,
    source_identifier TEXT NOT NULL,
    source_table TEXT,
    
    -- Generation metadata
    auto_generated BOOLEAN DEFAULT TRUE,
    generation_rule TEXT,
    
    -- Tracking
    last_generated_at TIMESTAMPTZ DEFAULT NOW(),
    generation_count INTEGER DEFAULT 1,
    
    -- Audit
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    is_active BOOLEAN DEFAULT TRUE,
    
    CONSTRAINT tr_unique_source UNIQUE (source_type, source_identifier)
);

CREATE INDEX IF NOT EXISTS idx_tr_source_type ON translation_registry(source_type);
CREATE INDEX IF NOT EXISTS idx_tr_source_id ON translation_registry(source_identifier);

COMMENT ON TABLE translation_registry IS 'Tracks all auto-generated translations for auditing';

-- =============================================================================
-- MASTER DATA TYPE TRANSLATION TRIGGER
-- =============================================================================

CREATE OR REPLACE FUNCTION generate_master_data_type_translations()
RETURNS TRIGGER AS $$
DECLARE
    v_locale TEXT;
    v_english_locales TEXT[];
BEGIN
    v_english_locales := get_english_locales();
    
    FOREACH v_locale IN ARRAY v_english_locales
    LOOP
        INSERT INTO master_data_translations (
            master_data_type_id,
            translation_target,
            locale_code,
            translated_label,
            translated_description,
            status,
            is_verified,
            is_auto_generated
        ) VALUES (
            NEW.id,
            'type',
            v_locale,
            to_title_case(NEW.type_key),
            NEW.description,
            'published',
            TRUE,
            TRUE
        ) ON CONFLICT DO NOTHING;
    END LOOP;
    
    -- Register in translation registry
    INSERT INTO translation_registry (source_type, source_identifier, source_table)
    VALUES ('master_data_type', NEW.id::TEXT, 'master_data_types')
    ON CONFLICT (source_type, source_identifier) DO UPDATE
    SET last_generated_at = NOW(),
        generation_count = translation_registry.generation_count + 1,
        updated_at = NOW();
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_master_data_type_translations ON master_data_types;
CREATE TRIGGER trg_master_data_type_translations
    AFTER INSERT ON master_data_types
    FOR EACH ROW
    EXECUTE FUNCTION generate_master_data_type_translations();

-- =============================================================================
-- MASTER DATA VALUE TRANSLATION TRIGGER
-- =============================================================================

CREATE OR REPLACE FUNCTION generate_master_data_value_translations()
RETURNS TRIGGER AS $$
DECLARE
    v_locale TEXT;
    v_english_locales TEXT[];
BEGIN
    v_english_locales := get_english_locales();
    
    FOREACH v_locale IN ARRAY v_english_locales
    LOOP
        INSERT INTO master_data_translations (
            master_data_value_id,
            translation_target,
            locale_code,
            translated_label,
            translated_description,
            status,
            is_verified,
            is_auto_generated
        ) VALUES (
            NEW.id,
            'value',
            v_locale,
            to_title_case(NEW.value_key),
            NULL, -- master_data_values has no description column
            'published',
            TRUE,
            TRUE
        ) ON CONFLICT DO NOTHING;
    END LOOP;
    
    -- Register in translation registry
    INSERT INTO translation_registry (source_type, source_identifier, source_table)
    VALUES ('master_data_value', NEW.id::TEXT, 'master_data_values')
    ON CONFLICT (source_type, source_identifier) DO UPDATE
    SET last_generated_at = NOW(),
        generation_count = translation_registry.generation_count + 1,
        updated_at = NOW();
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_master_data_value_translations ON master_data_values;
CREATE TRIGGER trg_master_data_value_translations
    AFTER INSERT ON master_data_values
    FOR EACH ROW
    EXECUTE FUNCTION generate_master_data_value_translations();

-- =============================================================================
-- BULK POPULATION FOR EXISTING DATA
-- =============================================================================

CREATE OR REPLACE FUNCTION populate_all_master_data_translations()
RETURNS INTEGER AS $$
DECLARE
    v_locale TEXT;
    v_english_locales TEXT[];
    v_insert_count INTEGER := 0;
    v_type RECORD;
    v_value RECORD;
BEGIN
    v_english_locales := get_english_locales();
    
    -- Types
    FOR v_type IN SELECT * FROM master_data_types WHERE is_active = TRUE
    LOOP
        FOREACH v_locale IN ARRAY v_english_locales
        LOOP
            INSERT INTO master_data_translations (
                master_data_type_id, translation_target, locale_code,
                translated_label, translated_description, 
                status, is_verified, is_auto_generated
            ) VALUES (
                v_type.id, 'type', v_locale,
                to_title_case(v_type.type_key), v_type.description,
                'published', TRUE, TRUE
            ) ON CONFLICT DO NOTHING;
            
            v_insert_count := v_insert_count + 1;
        END LOOP;
    END LOOP;
    
    -- Values
    FOR v_value IN SELECT * FROM master_data_values WHERE is_active = TRUE
    LOOP
        FOREACH v_locale IN ARRAY v_english_locales
        LOOP
            INSERT INTO master_data_translations (
                master_data_value_id, translation_target, locale_code,
                translated_label, translated_description,
                status, is_verified, is_auto_generated
            ) VALUES (
                v_value.id, 'value', v_locale,
                to_title_case(v_value.value_key), NULL, -- values have no description
                'published', TRUE, TRUE
            ) ON CONFLICT DO NOTHING;
            
            v_insert_count := v_insert_count + 1;
        END LOOP;
    END LOOP;
    
    RETURN v_insert_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- RLS POLICIES
-- =============================================================================

ALTER TABLE master_data_translations ENABLE ROW LEVEL SECURITY;

-- Authenticated users can read all translations
CREATE POLICY "Read translations" ON master_data_translations
    FOR SELECT TO authenticated
    USING (is_active = TRUE);

-- Admins can manage translations
CREATE POLICY "Admins manage translations" ON master_data_translations
    FOR ALL TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.app_role IN ('super_admin', 'admin', 'dev')
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.app_role IN ('super_admin', 'admin', 'dev')
        )
    );

ALTER TABLE translation_registry ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Read registry" ON translation_registry
    FOR SELECT TO authenticated
    USING (TRUE);

CREATE POLICY "Admins manage registry" ON translation_registry
    FOR ALL TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.app_role IN ('super_admin', 'admin', 'dev')
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.app_role IN ('super_admin', 'admin', 'dev')
        )
    );

-- =============================================================================
-- AUDIT TRAIL VERIFICATION: Check all translation tables have complete audit
-- =============================================================================

-- Add missing audit columns to existing translation tables if needed
DO $$
BEGIN
    -- schema_translations
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'schema_translations' AND column_name = 'created_by') THEN
        ALTER TABLE schema_translations ADD COLUMN created_by UUID REFERENCES profiles(id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'schema_translations' AND column_name = 'updated_by') THEN
        ALTER TABLE schema_translations ADD COLUMN updated_by UUID REFERENCES profiles(id);
    END IF;
    
    -- enum_translations
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'enum_translations' AND column_name = 'created_by') THEN
        ALTER TABLE enum_translations ADD COLUMN created_by UUID REFERENCES profiles(id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'enum_translations' AND column_name = 'updated_by') THEN
        ALTER TABLE enum_translations ADD COLUMN updated_by UUID REFERENCES profiles(id);
    END IF;
    
    -- ui_translations
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'ui_translations' AND column_name = 'created_by') THEN
        ALTER TABLE ui_translations ADD COLUMN created_by UUID REFERENCES profiles(id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'ui_translations' AND column_name = 'updated_by') THEN
        ALTER TABLE ui_translations ADD COLUMN updated_by UUID REFERENCES profiles(id);
    END IF;
    
    -- content_translations
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'content_translations' AND column_name = 'created_by') THEN
        ALTER TABLE content_translations ADD COLUMN created_by UUID REFERENCES profiles(id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'content_translations' AND column_name = 'updated_by') THEN
        ALTER TABLE content_translations ADD COLUMN updated_by UUID REFERENCES profiles(id);
    END IF;
END $$;

-- =============================================================================
-- RUN INITIAL POPULATION
-- =============================================================================

SELECT populate_all_master_data_translations();

-- =============================================================================
-- GRANTS
-- =============================================================================

GRANT SELECT ON master_data_translations TO authenticated;
GRANT SELECT ON translation_registry TO authenticated;
GRANT EXECUTE ON FUNCTION get_english_locales() TO authenticated;
GRANT EXECUTE ON FUNCTION to_title_case(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION populate_all_master_data_translations() TO authenticated;
